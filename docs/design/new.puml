@startuml
package "domain.game" {

    +class Card {
        - cardType: CardType
        - isMarked: boolean
        - isFacedUp: boolean

        + Card(cardType: CardType)
        + getCardType(): CardType
        + markCard(): void
        + checkIfMarked(): boolean
        + setFacedUp(): void
        + checkIfFacedUp(): boolean
    }

    enum CardType {
        NOPE
        DEFUSE
        ATTACK
        SHUFFLE
        SKIP
        SEE_THE_FUTURE
        CAT_ONE
        CAT_TWO
        CAT_THREE
        CAT_FOUR
        EXPLODING_KITTEN
        STREAKING_KITTEN
        SWAP_TOP_AND_BOTTOM
        GARBAGE_COLLECTION
        CURSE_OF_THE_CAT_BUTT
        ALTER_THE_FUTURE
        CATOMIC_BOMB
        SUPER_SKIP
        MARK
        IMPLODING_KITTEN
        REVERSE
        FERAL_CAT
        TARGETED_ATTACK
        DRAW_FROM_THE_BOTTOM

        - gameType: GameType
        - CardType(gameType: GameType)
    }

    enum GameType {
        NONE
        EXPLODING_KITTENS
        STREAKING_KITTENS
        IMPLODING_KITTENS
    }

    +class Deck {
        - deck: List<Card>
        - rand: Random
        - gameType: GameType
        - numberOfPlayers: int
        - maxDeckSize: int
        - instantiator: Instantiator

        + Deck(deck: List<Card>, rand: Random, gameType: GameType, numberOfPlayers: int, maxDeckSize: int, instantiator: Instantiator)

        + getDeckSize(): int
        + getCardAtIndex(index: int): Card
        + initializeDeck(): void
        + shuffleDeck(): void
        + insertCard(cardType: CardType, numberOfCards: int, bottom: boolean): void
        + drawCard(): Card
        + drawCardFromBottom(): Card
        + setNumberOfPlayers(numberOfPlayers: int): void
        + chooseGameType(gameType: GameType): void
        + removeBombs(): int
        + insertExplodingKittenAtIndex(indexToInsert: int): void
        + insertImplodingKittenAtIndex(indexToInsert: int, card: Card): void
        # getCardTypeAtIndex(index: int): CardType
        + reorderDeckCards(newOrderIndices: int[], cardsToReorder: List<Card>): void

        - addedOutOfBounds(numberOfCards: int): boolean
        - checkIfExplodingKitten(index: int): boolean
        - checkIfIndexOutOfRange(index: int): boolean
    }

    +class Player {
        - playerID: int
        - hand: List<Card>
        - isDead: boolean
        - rand: Random
        - isCursed: boolean

        + Player(playerID: int, instantiator: Instantiator)

        + getPlayerID(): int
        + addDefuse(defuse: Card): void
        + addCardToHand(card: Card): void
        + hasCard(cardType: CardType): boolean
        + getHandSize(): int
        + getCardAt(index: int): Card
        + getIndexOfCard(cardType: CardType): int
        + removeCardFromHand(index: int): CardType
        + shuffleHand(): void
        + checkNumberOfCardsInHand(cardType: CardType): int
        + getIsDead(): boolean
        + setIsDead(): void
        + getIsCursed(): boolean
        + setCursed(isCursed: boolean): void
    }

    +class Instantiator {
        + createCard(cardType: CardType): Card
        + createRandom(): Random
        + createCardList(): ArrayList<Card>
    }

    ' Observer for Observer pattern
    +interface GameObserver {
        + onCardPlayed(event: GameEvent): void
        + onGameOver(event: GameEvent): void
    }

    +class GameEvent {
        + {final} type: GameEventType
        + {final} actorPlayerIndex: int
        + {final} cardType: CardType

        + GameEvent(type: GameEventType, actorPlayerIndex: int, cardType: CardType)
        + getType(): GameEventType
        + getActorPlayerIndex(): int
        + getCardType(): CardType
    }

    enum GameEventType {
        CARD_PLAYED
        TURN_ENDED
        GAME_OVER
    }

    +class Game {
        - numberOfPlayers: int
        - gameType: GameType
        - deck: Deck
        - players: Player[]
        - rand: Random

        - currentPlayerTurn: int
        - currentPlayerNumberOfTurns: int
        - isReversed: boolean
        - attackQueue: List<Integer>
        - attackCounter: int
        - numberOfAttacks: int
        - turnTracker: int[]
        - attacked: boolean

        - observers: List<GameObserver>

        + Game(numberOfPlayers: int, gameType: GameType, deck: Deck, players: Player[], rand: Random, attackQueue: List<Integer>, turnTracker: int[])

        + swapTopAndBottom(): void
        + stealRandomCard(playerToStealFrom: int): Card
        + stealTypeCard(cardType: CardType, playerToStealFrom: int): void

        + startAttackPhase(): void
        + playAttack(): void
        + playTargetedAttack(attackedPlayerIndex: int): void

        + playExplodingKitten(playerIndex: int): boolean
        + playImplodingKitten(): void
        + playDefuse(idxToInsertExplodingKitten: int, playerIndex: int): void
        + drawFromBottom(): Card
        + playCatomicBomb(): void

        + setNumberOfPlayers(numberOfPlayers: int): void
        + playReverse(): void
        + retrieveGameMode(gameType: GameType): void
        + selectRandomPlayer(): Player
        + playShuffle(numberOfShuffles: int): void
        + playSkip(superSkip: boolean): int
        + playGarbageCollection(cardToDiscard: CardType): void

        + getDeck(): Deck
        + incrementPlayerTurn(): void
        + incrementAttackCounter(): void
        + setAttackCounter(playerIndex: int): void

        ~ getGameTypeForTesting(): GameType
        + getGameType(): GameType
        + getPlayerAtIndex(playerIndex: int): Player

        + addAttacks(): void
        + playMark(playerIndex: int, cardIndex: int): void

        + addAttackQueue(attack: int): void
        + removeAttackQueue(): int
        + isAttackQueueEmpty(): boolean

        + setPlayerNumberOfTurns(): void
        + getPlayerTurn(): int
        + getNumberOfPlayers(): int
        + checkNumberOfAlivePlayers(): int
        + setCurrentPlayerNumberOfTurns(numberOfTurns: int): void
        + decrementNumberOfTurns(): void
        + getNumberOfTurns(): int

        + getDeckSize(): int
        + drawCard(): Card
        + getCardAtIndex(cardIndex: int): Card

        + removeCardFromHand(playerIndex: int, cardType: CardType): void
        + getIndexOfCardFromHand(playerIndex: int, cardType: CardType): int
        + addCardToHand(card: Card): void
        + checkIfPlayerDead(playerIndex: int): boolean
        + checkIfPlayerHasCard(playerIndex: int, cardType: CardType): boolean
        + getCardType(playerIndex: int, cardIndex: int): CardType
        + getHandSize(playerIndex: int): int
        + getDeckCardType(deckIndex: int): CardType

        + getIsReversed(): boolean

        # setCurrentPlayerTurn(turn: int): void

        - matchingGameType(gameType: GameType): boolean
        - checkCardOutOfBoundsIndexed(cardIndex: int, playerIndex: int): boolean
        - checkUserOutOfBounds(userIndex: int): boolean
        - checkDeckHasOneCardOrLess(): boolean
        - checkPlayerHandEmpty(player: Player): boolean
        - checkInvalidNumberOfPlayers(numPlayers: int): boolean
        - hasZeroPlayers(): boolean
        - checkIfNumberOfTurnsOutOfBounds(): boolean
        - checkIfNumberOfTurnsIsZero(): boolean

        + setTurnToTargetedIndexIfAttackOccurred(): void
        + getTurnCountOfPlayer(playerIndex: int): int
        + getAttacked(): boolean
        + getAttackCounter(): int
        + getNumberOfAttacks(): int

        ~ setNumberOfAttacks(numberOfAttacks: int): void
        ~ setAttacked(attacked: boolean): void

        ' new observer API for refactor
        + addObserver(observer: GameObserver): void
        + removeObserver(observer: GameObserver): void
        - notifyCardPlayed(actorPlayerIndex: int, cardType: CardType): void
        - notifyGameOver(): void
    }
}

domain.game.Deck  "1" o-- "*" domain.game.Card        : cards >
domain.game.Player "1" o-- "*" domain.game.Card       : hand >
domain.game.Game  "1" o-- "1" domain.game.Deck        : deck >
domain.game.Game  "1" o-- "*" domain.game.Player      : players >
domain.game.Card       --> "1" domain.game.CardType   : has type >
domain.game.CardType   --> "1" domain.game.GameType   : belongs to >
domain.game.Deck       "1" o-- "1" domain.game.Instantiator : instantiator >
domain.game.Player     "1" o-- "1" domain.game.Instantiator : instantiator >
domain.game.Game       "1" o-- "*" domain.game.GameObserver : observers >
domain.game.GameObserver ..> domain.game.GameEvent
domain.game.Game ..> domain.game.GameEvent
domain.game.GameEvent --> domain.game.CardType
domain.game.GameEvent --> domain.game.GameEventType

package "application" {

    +class CardPlayContext {
        - currentPlayerIndex: int
        - targetPlayerIndex: Integer
        - card: domain.game.Card
        - cancelled: boolean

        + CardPlayContext(currentPlayerIndex: int, card: domain.game.Card)
        + setTargetPlayerIndex(targetPlayerIndex: int): void
        + getCurrentPlayerIndex(): int
        + getTargetPlayerIndex(): Integer
        + getCard(): domain.game.Card
        + cancel(): void
        + isCancelled(): boolean
    }

    +interface CardEffect {
        + apply(game: domain.game.Game, context: CardPlayContext): void
    }

    abstract class AbstractCardEffect {
        + apply(game: domain.game.Game, context: CardPlayContext): void
        # validate(game: domain.game.Game, context: CardPlayContext): void
        # doApply(game: domain.game.Game, context: CardPlayContext): void
    }

    CardEffect <|.. AbstractCardEffect

    +class ExplodingKittenEffect {
        + ExplodingKittenEffect()
        # validate(game: domain.game.Game, context: CardPlayContext): void
        # doApply(game: domain.game.Game, context: CardPlayContext): void
    }

    +class NopeEffect {
        + NopeEffect()
        # validate(game: domain.game.Game, context: CardPlayContext): void
        # doApply(game: domain.game.Game, context: CardPlayContext): void
    }

    +class ShuffleEffect {
        + ShuffleEffect()
        # validate(game: domain.game.Game, context: CardPlayContext): void
        # doApply(game: domain.game.Game, context: CardPlayContext): void
    }

    +class SkipEffect {
        + SkipEffect()
        # validate(game: domain.game.Game, context: CardPlayContext): void
        # doApply(game: domain.game.Game, context: CardPlayContext): void
    }

    +class NullEffect {
        + NullEffect()
        + apply(game: domain.game.Game, context: CardPlayContext): void
    }

    AbstractCardEffect <|-- ExplodingKittenEffect
    AbstractCardEffect <|-- NopeEffect
    AbstractCardEffect <|-- ShuffleEffect
    AbstractCardEffect <|-- SkipEffect
    CardEffect <|.. NullEffect

    +class CardEffectFactory {
        + CardEffectFactory()
        + createEffect(cardType: domain.game.CardType): CardEffect
    }

    +class CardPlayService {
        - game: domain.game.Game
        - effectFactory: CardEffectFactory

        + CardPlayService(game: domain.game.Game,
                          effectFactory: CardEffectFactory)

        + playCard(context: CardPlayContext): void
    }
}

application.CardPlayContext "1" o-- "1" domain.game.Card : playedCard >
application.CardEffectFactory ..> domain.game.CardType
application.CardEffectFactory ..> application.CardEffect
application.CardPlayService "1" o-- "1" domain.game.Game           : game >
application.CardPlayService "1" o-- "1" application.CardEffectFactory : effectFactory >
application.CardPlayService ..> application.CardPlayContext
application.CardPlayService ..> application.CardEffect
application.AbstractCardEffect ..> domain.game.Game
application.AbstractCardEffect ..> application.CardPlayContext

@enduml
